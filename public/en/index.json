


[{"content":" Graph-Skeleton: ∼1% Nodes are Sufficient to Represent Billion-Scale Graph论文阅读 # Abstract # 图数据的在网络上的普遍存在让其有着很广泛的应用，包括网页搜索、社交网络分析、区块链、推荐系统、交通流预测等。然而，在大规模网络图上部署图模型仍然是一个巨大的挑战。尽管有许多研究致力于提高图模型的可扩展性，但学术研究与工业场景之间仍然存在明显的差距。一个主要原因是，在大多数工业场景中，网络图中的只有一小部分节点需要被分析，我们称这些节点为目标节点，而其他节点为背景节点。\n在本文中，我们提出，通过从海量网络图数据中合理获取并压缩背景节点，可能是从根本上解决这些障碍的更经济的捷径。为此，我们首次尝试研究目标节点分类中的大规模背景节点压缩问题。通过广泛的实验，我们揭示了背景节点在目标节点分类中扮演的两个关键角色：增强目标节点之间的结构连通性，以及与目标节点的特征相关性。基于此，我们提出了一种新颖的Graph-Skeleton模型，该模型合理地获取背景节点，并进一步压缩相似目标-背景局部结构中背景节点的语义和拓扑信息。在各种网络图数据集上的大量实验表明了该方法的有效性和效率。特别是在包含2.4亿个节点的MAG240M数据集上，我们生成的骨架图在仅包含原始图1.8%节点的情况下，仍然实现了高度可比的性能。\nIntroduction # 图数据的普遍存在，尤其是在网络图形式下，使得网络图挖掘成为一个热门的研究话题。这些网络图在诸多应用中至关重要，包括网页搜索、社交网络分析、区块链、推荐系统等。然而，在大规模网络图上部署图模型仍然是一个巨大的挑战。实际上，网络图数据可能极其庞大。以Facebook为例，每月有超过29.3亿的活跃用户。\n尽管在提升图模型在大规模网络图挖掘任务上的可扩展性方面已经取得了显著进展，例如节点采样、模型简化等，但学术研究与实际应用之间仍然存在很大的差距。一个主要原因是在大多数工业场景中，并非网络图中的所有节点都需要被分析。\n我们以DGraph（一个真实的金融与社交网络数据集，用户作为节点，用户之间的社交关系作为边）为例，进一步说明这一点。以贷款用户中的欺诈者识别任务为例，只有那些有贷款记录的用户需要被分类，而没有贷款行为的其他用户则不需要。在这种情况下，我们将贷款用户称为目标节点，而将其他用户称为背景节点。这种目标与背景的属性在网络图挖掘场景中普遍存在。此外，背景节点的数量通常远远大于目标节点。例如，在MAG240M数据集中，要预测论文的学科领域，只有140万篇Arxiv论文需要被分类，而总节点数却有2.4亿个。\nEmpirical Analysis # 两个疑问 # 背景节点对于目标节点的分类是否是必要的？ 背景节点在目标节点的分类中发挥什么作用？ 为了回答这两个问题，作者使用SAGE、GAT、GIN三种采用不同聚合方式（求平均、加权求和、求和）的用于进行分类任务的模型对以上疑问进行分析。\n数据集 # 金融贷款网络 DGraph：我们遵循原始数据集的任务设置，即在贷款用户中识别欺诈者，因此有贷款行为的用户被视为目标节点（约33%），而其他用户则为背景节点。 学术引用网络 ogbn-arxiv：我们旨在预测2018年以后发表的论文的学科领域，在这种情况下，2018年后发表的论文被视为目标节点（约46%），而2018年之前的论文则为背景节点。 对于疑问一：\n尝试进行随机切割边、切割所有边B-B、切割所有边T-B、切割所有边T-T，并与原始的图进行对比。最终发现，切割T-B、T-T均会对预测准确率有显著下降，而切割B-B则不会，甚至在某些数据集上还有提升。\n对于疑问二：\n实验发现对于连接了两个T的B(桥接节点)，如果删除了这些T-B边(BridB)，模型预测的准确率会有显著下降，说明这些T-B关系对于模型的性能具有显著贡献。另外，从图中的结果可以看出，切割BridB的效果均好于T-B，说明维持T-T之间的连通性也是十分有必要的。\n其他猜想 # 假设背景节点与其相似的目标节点之间具有更高的特征相关性，为此计算了目标节点与其不同跳数的背景节点之间的Pearson系数。从结果来看，越靠近目标节点的背景节点往往会具有更高的相关性。这表明与单个目标相邻的背景节点的特征可能与目标本身的特征相关，从而影响模型的性能。\n分析结论 # 大多数背景节点是多余的 背景节点在目标节点分类任务中以如下两种方式发挥作用 作为桥接节点(brige)提供目标节点之间的联通性 与单独的目标节点相连，作为关联节点(affiliation)提供特征相关性 Methodology # 问题定义 # 在大规模图$G = (V, E)$ 中，针对一个特定的节点分类任务，我们可以得到一个相应的节点集合 $T = {T_1, T_2, \\dots, T_n}$，其中包含了需要进行分类的节点。在大多数实际场景中，节点集合 $T$ 的大小远小于图中所有节点的总数 $|V|$。\n在这篇论文中，我们将 $T$ 称为目标节点(target nodes)，而图 $G$ 中的其他节点则称为背景节点(background nodes)，记作 $B := V \\setminus T = {B_1, B_2, \\dots, B_{|V| - n}}$。图 G 同时还与节点特征 $X \\in \\mathbb{R}^{|V| \\times d}$ 和目标节点标签$Y\\in {0, \\dots, C - 1}^n$相关联。考虑到大多数节点都是背景节点，我们的目标是生成一个具有高度信息量的合成图 $G\u0026rsquo;$，同时显著减少背景节点的数量。除此之外，论文主要关注对目标节点的分类情况，因此仅对背景节点进行压缩，而保留了所有原始的目标节点。\n框架概述 # 为了应对大规模网络图中的问题，作者提出了一种新颖的Graph-Skeleton框架，用于从庞大的网络图中生成一个具有更小规模但信息丰富的骨架子图(skeleton subgraph)，以便进行目标分类。\n第一步-节点提取：框架首先提取所有的目标节点以及部分背景节点，构建一个基础子图(vanilla subgraph)。作者根据结构连通性和特征相关性提出了一种提取原则，来合理提取对应的节点。（下图Node Fetching部分） 第二步-图凝聚：Graph-Skeleton对基础子图的信息进行压缩，以减少冗余。具体来说，作者设计了三种图凝聚策略（即𝛼, 𝛽, 𝛾），压缩程度从低到高不等。（下图Graph Condensation部分） 第三步-分类任务：压缩后的图具有高度的信息量，同时享有小规模带来的存储和图模型部署的优势。可将其应用于各种GNN模型进行分类任务。 1. 节点提取 # 上一部分得出的结论是背景节点是高度冗余的，因此初步的想法是进行关键节点的提取，从庞大的原始数据中适当地提取桥接和关联背景节点。利用这些节点，我们可以构建一个包含所有目标节点以及一小部分背景节点的初始子图(vanilla subgraph)。\n为了解决过度扩展问题，为了解决过度扩展问题，我们根据自定义的节点提取深度和宽度(即 $d_1、d_2、K \\in \\mathbb{N}$)进行节点的提取。具体遵循以下两个原则：\n结构连通性：在$d_1$跳内连接两个或多个目标节点的视为桥接节点进行保留。 特征相关性：对于每个单独的目标节点，在$d_2$跳范围内，与目标节点特征相关性最高的$K$个背景节点视为关联节点进行保留。 因此首要目标是找到每个目标节点的所有可访问的背景节点(可访问指的是可从仅由背景节点组成的路径到达)。\n*本论文中将超参数规定为$d_1=3, d_2=1,k=2$\n对于原则1-结构连通性：\n找背景节点：通过对每个目标节点使用BFS找所有可到达的背景节点 找最短路径：假设背景节点 $B_j$ 可以访问目标节点集合为${T_{k1}, T_{k2}, \u0026hellip;, T_{ki}}$，则对应的最短路径集可以表示为 $P_{Bj} = {p_{k1,j}, p_{k2,j}, \u0026hellip;, p_{ki,j}}$，计算这些路径长度$d(P_{Bj}) = {d(p_{k1,j}), \u0026hellip;, d(p_{ki,j})}$ （其中 d(t) 是距离函数），并将这些路径长度的最小值和第二小值相加，得到$sd_j = \\min [ d(P_{Bj}) ] + \\min 2nd [ d(P_{Bj}) ]$ 判断是否为桥接节点：如果$sd_j≤d_1$，这意味着背景节点 $B_j$ 在 $d_1$跳范围内至少连接了两个目标节点，因此将其视为桥接节点。 通过遍历所有背景节点，可以得到一个包含所有桥接节点的节点子集$BR$。\n对于原则2-特征相关性：\n找背景节点：通过对每个目标节点 $T_i$ 执行BFS，获得 $T_i$ 到其所有可访问背景节点的最短路径集合。设 $J := { j_1, j_2, \u0026hellip;, j_k }$ 为 $T_i$ **可访问背景节点的索引集合，对应的最短路径集合为 $P_{T_i} := { p_{i,j} }$，其中 $j \\in J, p_{i,j}$ 表示从 $T_i$ 到某个可访问背景节点 $B_j$ 的最短路径。 判断距离：选择那些最短路径距离在 $d_2$ 以内的可访问背景节点，即 ${ B_m, m \\in J, s.t., d(p_{i,m}) \\leq d_2 }$ 计算相关性：为了选择最重要的 $K$ 个背景节点，我们需要计算每个被选中的 $B_m$ 与 $T_i$ 之间的特征皮尔逊相关系数 (PCC): $$ PCC_im=\\frac{cov(X[i],X[m])}{σ_{X[i]}⋅σ_{X[m]}} $$\n筛选关联节点：选择相关性最高的$K$个背景节点作为关联节点。 通过遍历所有目标节点，可以获得一个关联背景节点子集 $AF$。\n构建子图：\n将目标节点 $T$ 和抓取到的背景节点$B\u0026rsquo; = { BR, AF }$ 保留在原始图 $G$ 中，构建一个子图 $G\u0026rsquo; = (V\u0026rsquo;, E\u0026rsquo;)$\n概念定义 # 为了减少信息冗余，我们为构建的原始子图 $G\u0026rsquo;$ 设计了一个凝缩过程，有效地凝缩了结构信息和语义信息。具体来说，我们提出了三种图凝缩策略，分别标记为 $\\alpha$、$\\beta$ 和 $\\gamma$，它们提供了从低到高不同程度的凝缩效果。\n$MSS$(multiple structure-set, 多重结构集)：背景节点$j$可前往的所有目标节点的集合及到达该节点的距离 $$ MSS_j={{⟨T_i,d_{i,j}⟩,\u0026hellip;,⟨T_{k},d_{k,j}⟩}} $$\n节点对等价类(Node Pair Equivalence Class)：给定图 $G$上的函数族 $F$，定义所有图节点对之间的等价关系 $≃_F$，使得对于所有 $u, v \\in V$，当且仅当 $\\forall f \\in F，f(G,X) = f(G, \\tilde{X})$，其中 $\\tilde{X}$与 $X$ 相同，但 $\\tilde{X}[u] = X[v]$ 和 $\\tilde{X}[v] = X[u]$。\n即对于图上两个节点交换两个节点特征后函数返回相同的结果，则这两个节点对等价\n线性消息传递(Linear message passing operation, $lmp$) 给定两个连接的节点 $u$ 和 $v$，定义从 $u$ 到 $v$ 的线性消息传递操作$f_{lmp}(u, v)$ 为：\n$$ X\u0026rsquo;[v] \\leftarrow f_{lmp}(X[v], X[u]) = \\text{AGGREGATE}({X[v], X[u]})W $$\n其中 $W$ 是一个变换矩阵，$\\text{AGGREGATE}$ 可以表述为逐元素均值或求和池化。\n线性路径消息传递(Linear message path passing)：给定一条路径 $p = \\langle u_0, u_1, \u0026hellip;, u_\\ell \\rangle$，对于所有 $u_i \\in V$，定义从 $u_0$ 到 $u_\\ell$沿路径 $p$ 聚合节点特征的线性路径传递函数 $f_{spp}(X, p)$为： $$ X\u0026rsquo;[u_i] \\leftarrow f^i_{lmp}(X\u0026rsquo;[u_{i-1}], X[u_i])W_i, \\quad i \\in 1, \u0026hellip;, \\ell $$\n线性路径消息传递等价类(Linear message path passing equivalence class，LMPP等价类)：\n给定一组线性路径消息传递函数$LMPP$，两个节点$u, v \\in V$ 和一个共同可达节点$K \\in V$，对应的路径分别为$p_{u,K} := \\langle u, \u0026hellip;, K \\rangle$ 和$p_{v,K} := \\langle v, \u0026hellip;, K \\rangle$，令$P := {p_{u,K}, p_{v,K}}$，定义$u≃_{LMPP,K}v$ 的LMPP等价关系为：\n$$ u≃{LMPP,K}v⟺∀f{lmpp}∈LMPP,f_{lmpp}(X,P) =f_{lmpp}(\\tilde X,P) $$\n其中 $\\tilde{X}$与 $X$ 相同，但 $\\tilde{X}[u] = X[v]$ 和 $\\tilde{X}[v] = X[u]$。\n设 $T \\in \\text T$ 表示图 $G$ 中的一个目标节点，$B$ 表示背景节点的集合，对于所有 $u, v \\in B$，如果 $MSS_u = MSS_v \\neq \\emptyset$那么$u ≃_{LMPP,T}v$\n若两节点的mss相同，则它们lmpp等价\n2. 图凝聚策略 # 策略-𝛼：因为具有相同mss的背景节点沿路径进行聚合的方式类似，聚合得到的结果也类似。将所有具有相同mss的背景节点进行聚合压缩，变为一个合成节点。给定一个背景节点的集合$B^′_k={B_i,\u0026hellip;,B_j}$，这些节点之间具有相同的MSS，将要聚合到的点$B^′k$的特征$x{B^′_k}$为： $$ x_{B^′_k}← \\text {AGGREGATE}({x_v,∀v∈B^′_k}) $$\n$\\text{AGGREGATE}$ 可以表述为逐元素均值或求和池化。\n策略-𝛽：策略-𝛼通过多重结构集（MSS）凝聚具有相同结构信息的背景节点，但其压缩效果有限，因为只有一部分严格共享相同的 ${\\langle T, d \\rangle}$的背景节点会进行聚合。为提高效率，修改mss为$MSS\u0026rsquo;j={{⟨T_i⟩,\u0026hellip;,⟨T{k}⟩}}$，并在此基础上进行节点的聚合。\n但是需要注意的是，在将背景节点合并压缩时，图的相对距离信息可能会丢失。具体来说，当多个桥接节点被合并成一个节点时，原本距离较远的目标节点之间的相对距离会缩短。例如，原本相隔几跳的目标节点，在压缩后的图中可能通过一个1跳的桥接节点连接在一起。\n对于一个与 $B\u0026rsquo;k$ **通过边$e\u0026rsquo;{m,k}$ 连接的可达目标节点 $T_m$，设 $B\u0026rsquo;k$ 到 $T_m$ 的最短距离集合为$D_m := {d{m,i}, \u0026hellip;, d_{m,j}}$。那么边 $e\u0026rsquo;{m,k}$ 的权重$w\u0026rsquo;{m,k}$ 可以表示为：\n$$ w^′_{m.k}= \\sum _{d\\in D_k}\\frac{1}{d} $$\n策略-γ：尽管策略-β有效地减少了桥接节点的数量，但在进一步凝聚关联节点方面仍有改进的空间。给定一个原始子图$G^′$，我们首先执行策略-β来凝聚桥接节点，然后在生成的骨架图$S_β$中凝聚关联节点。具体而言，给定$S_β$中的一个目标节点$T_𝑘$，以及其对应的关联背景节点集$AF_𝑘$，我们通过将$T_𝑘$的特征与$AF_𝑘$的特征进行整合来更新$T_𝑘$的特征，然后在$G^′$中移除$AF_𝑘$。\n通过这种方式，我们在去除大量关联节点的同时，保留了大部分来自关联节点的原始相关信息。凝聚后$T_𝑘$的特征$x_{T_k}$是通过与$AF_𝑘$的原始特征聚合而成的，具体公式如下：\n$$ x_{T_k} \\leftarrow \\text{AGGREGATE}\\left({x_{T_k} \\cup {x_u, \\forall u \\in AF_k}}\\right) $$\n许多具有代表性的图神经网络（GNNs）采用传播过程来合并来自邻居节点的信息。直观上，直接将关联节点的特征聚合到相邻的目标节点上，会与递归聚合（即通过多次传播过程逐步聚合信息）的结果相似。\nExperiments # 实验准备 # 为了全面评估所提出的 Graph-Skeleton 的性能，我们在六个 Web 数据集上进行了目标节点分类任务：DGraph、ogbn-mag、ogbn-arxiv、MAG240M、DBLP 和 IMDb，只考虑删除所有的背景节点的情况。数据集的规模如下：\nbaseline方法 # 在实验设置中，我们将目标节点分类性能与原始图和其他图压缩基线方法进行了比较，包括核心集方法（随机、使用PageRank中心性的中心性排序（Central-P）和使用度中心性的中心性排序（Central-D））、图粗化方法（变异邻域粗化（GC-VN）、代数JC粗化（GC-AJC）、使用舒尔补数的谱粗化（SchurC））、图凝聚方法（GCond、DosCond）以及图主动学习方法（GPA）等。需要注意的是，我们的目标是在压缩背景节点的同时保留所有目标节点。压缩率通过背景节点压缩率（BCR）来表示，即合成背景节点与原始背景节点的比例。\n在通过上述方法获得压缩图后，我们采用图神经网络（GNNs）来评估其目标分类性能。考虑到不同的数据集适用于不同的GNNs，对于DGraph、ogbn-arxiv、ogbn-mag和MAG240M，我们选择各自官方排行榜上表现最好的GNNs进行评估。对于IMDB和DBLP，我们采用最具代表性的GNNs（GCN、GraphSAGE、GAT）进行评估。DGraph的目标分类性能通过AUC（%）来评估，其他数据集则通过ACC（%）来评估。\n图压缩对比 # 我们首先在表2中报告了在固定压缩率（BCR）下，压缩图在六个数据集上的目标节点分类结果。在此，我们将使用策略-𝛾的Graph-Skeleton（简称Skeleton-𝛾，具有最高压缩率）的性能与其他基线方法进行了比较。\n正如我们所见，Skeleton-𝛾在将GNNs扩展到所有数据集方面表现出强大的能力。此外，在相似的BCR下，它还比其他压缩基线方法实现了更优越的目标分类性能。此外，与其他因内存和计算负担严重受限的图粗化和压缩方法相比，我们的方法在部署于大规模网络图时更具友好性。值得注意的是，与原始图相比，Skeleton-𝛾在显著减少背景节点数量的同时，也表现出高度可比甚至更好的目标分类性能。\n此外，我们在图6中报告了压缩图在不同BCR（背景节点压缩率）下的目标分类结果。通过选择Graph-Skeleton的不同压缩策略以及不同的节点抓取深度（𝑑1, 𝑑2），我们可以灵活地实现不同的压缩率。可以很容易地观察到，在更广泛的压缩率范围内，我们的方法显著优于其他方法。\n存储消耗对比 # 我们报告了在固定背景节点压缩率（𝐵𝐶𝑅）下，原始图和Skeleton-𝛾在六个数据集上的网页图存储的内存成本。为了更直观地呈现结果，我们将图数据的存储成本分解为三个主要方面：目标节点特征的成本、背景节点特征的成本和图的邻接矩阵的成本。结果如表3所示。可以看到，Skeleton-𝛾显著减少了背景节点特征和图邻接矩阵的内存成本（表3中的绿色部分）。由于在压缩后的Skeleton-𝛾中保留了所有的目标节点，目标节点特征的存储成本与原始图保持一致。另一方面，Skeleton-𝛾还在性能上达到了与原始数据接近甚至更好的效果。这突显了我们提出的方法在保留目标节点分类所需的关键信息方面的有效性。\n三种图凝聚策略对比 # 我们研究了Graph-Skeleton提出的三种压缩策略𝛼、𝛽和𝛾的压缩性能。具体来说，我们使用相同的基础子图作为输入，并采用这三种策略进行压缩。图中左轴（蓝色）表示背景节点压缩率（𝐵𝐶𝑅，柱状图），右轴（红色）表示目标节点分类性能（虚线）。正如我们所见，Skeleton-𝛼、𝛽、𝛾在目标节点分类性能上都与原始数据表现出极具竞争力的效果，表明这三种压缩策略的有效性。通常来说，Skeleton-𝛼在三种策略中表现出最佳的分类性能，这是由于信息损失较少。另一方面，Skeleton-𝛾在所有测试的下游GNN中也很好地逼近了原始性能，同时具有显著更高的𝐵𝐶𝑅，表明将附属背景节点的特征聚合到相邻目标节点上可以很好地保留原始背景节点的信息。\n拓展与思考 # 图压缩的策略能否用于表示路网结构，以解决ETA相关问题？\nETA背景下交通图特点 # 数据量大：交通图包含时空两个维度的数据，以北京为例，其包含2733734 条link，单日数据维度 2733734 * 1440，难以直接以图的方式输入模型计算 **时间空间特征明显：**交通图在时间上和空间上均存在明显特征。时间上，从星期来看存在工作日和休息日的星期差异；从天来看存在早晚高峰和其他时段的时间差异。空间上，某一路段周围道路的路况变化往往会对其造成影响；一条路段上的多个link存在前后关联 存在大量数据冗余：以北京20240801数据为例，当日无路况发布的link为2033166 (约占74%)，这些link在图中的作用仅仅表现为图结构上的联通性 有何思路可以借鉴？ # 学习论文中节点提取的思想，只保留具有结构连通性和特征相关性的link构成图结构 学习论文中图凝聚的思想，构建不同link的特征相关函数，并依据相关性进行link聚合 ","date":"2024-09-20","externalUrl":null,"permalink":"/posts/graph_skeleton/","section":"文章","summary":"","title":"Graph Skeleton论文阅读","type":"posts"},{"content":"","date":"2024-09-20","externalUrl":null,"permalink":"/tags/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","section":"Tags","summary":"","title":"图神经网络","type":"tags"},{"content":"","date":"2024-09-20","externalUrl":null,"permalink":"/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","section":"Tags","summary":"","title":"学习笔记","type":"tags"},{"content":"","date":"2024-09-20","externalUrl":null,"permalink":"/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","section":"Tags","summary":"","title":"机器学习","type":"tags"},{"content":" GAT(Graph Attention Networks) # 论文：https://arxiv.org/pdf/1710.10903\n图注意网络（Graph Attention Networks，GAT）是一种用于图结构数据的神经网络模型，通过引入注意力机制，能够有效地捕捉节点间的关系。GAT由Petar Veličković等人在2017年提出，是在图卷积网络（Graph Convolutional Networks，GCN）的基础上发展而来的。\n","date":"2024-06-11","externalUrl":null,"permalink":"/posts/gnn_pt2/","section":"文章","summary":"","title":"图神经网络学习笔记（2）","type":"posts"},{"content":"","date":"2024-05-27","externalUrl":null,"permalink":"/funs/","section":"Funs","summary":"","title":"Funs","type":"funs"},{"content":"","date":"2024-05-27","externalUrl":null,"permalink":"/tags/%E6%A1%8C%E6%B8%B8/","section":"Tags","summary":"","title":"桌游","type":"tags"},{"content":" 最近玩《璀璨宝石》有点上头，网上找到了一篇分析牌型的文章，转载于此便于学习\n一．色环 # 璀璨宝石中的颜色存在相互关联性，五色色环如下：\n——黑——红——绿——蓝——白——黑——红——绿——蓝——\n为了后面叙述方便，顺时针下一个颜色称为顺临色，顺时针下两个颜色称为顺对色，逆时针下一个颜色称为逆临色，逆时针下两个颜色称为逆对色。以白色为例，黑色是白色的顺临色，红色是白色的顺对色，蓝色是白色的逆临色，绿色是白色的逆对色。\n璀璨宝石设计的一大特点是卡牌上的宝石元素并不完全是镜像排列的，虽然五个颜色的卡牌数量一致，宝石和分数的模型一致，但是组合方式却并非完全一致，这赋予了各个颜色不同的“特性”。不同局势下，颜色之间关联的差异，使得玩家的策略更多变，增加了游戏的策略度和可玩性。\n二．三级卡（20张）： # 73： 3本色 7顺临（5）\n游戏中唯一的5分卡，行动数量-分数比一般为7:5=1.4，是性价比最高的一张得分牌。但受制于宝石上限10，一般在中后期才有机会完成，不建议早期预留，一旦操作不好，很容易中期被卡住。\n单7： 7顺临（4）\n单色7换4分，行动数量-分数比一般为7:4=1.75，虽然性价比低于73，不过胜在只需要7枚宝石就可以完成，是有机会在前期就打出来解放一个预留位置的，在翻出的3级牌普遍较差的情况下可以考虑前期预留。\n633： 6顺临 3本色 3顺对（4）\n后期性价比比较高的一张牌，行动数量-分数比一般为6:4=1.5，由于需要12枚宝石，一般后期才有机会打出，可以作为收尾牌.\n5333： 5顺对 3顺临 3逆对 3逆临（3）\n几乎任何流派都不会作为核心的一张牌，行动数量-分数比一般为7:3=2.3，基本属于三级牌里的垃圾牌，极少数情况下贵族流收尾补分会选择它。\n三级牌小结：三级牌整体五色排列非常整齐，没有体现出颜色之间的差异性。单看性价比三级牌都是非常高的，但受制于宝石数量和宝石上限，在没有低级牌支撑的情况下贸然冲三级牌是很容易卡住的，因此预留三级牌的时机和选择非常考验玩家对游戏节奏的把握。另外可以看到所有比较强的三级牌都对顺临色需求最大，那么在选定收尾三级牌颜色的同时，顺临色牌的价值也会随之变大。例如如果我想以三级绿牌收尾，那么本局前面我应尽量收集蓝宝石牌。\n三．二级卡（30张）： # 单6： 6本色（3）\n二级牌中的最高分牌，行动数量-分数比一般为6:3=2，在二级牌中算是相当优秀的性价比了。另外本牌是本色生本色，属于强化颜色体系构成，对争夺三级牌和贵族都有益处，这点也侧面提高了它的价值。但是本牌需要6同色，完成难度是二级牌中最大的，前期预留需谨慎。\n53： 绿：3本色 5顺临（2） 蓝：3本色 5顺临（2） 白：3顺临 5顺对（2） 黑：3顺临 5顺对（2） 红：3逆对 5逆临（2）\n8宝石换2分，行动数量-分数比一般为6:2=3，性价比平平。二级牌中就开始出现有颜色差异的牌了，53牌中，绿蓝两色延续了和三级牌73牌相同的主顺临，辅本色的构成，而白黑红三色则几乎构成了一个三色闭环。本牌优先级不高，通常不需要前期预留。\n单5： 绿：5本色（2） 蓝：5本色（2） 白：5顺对（2） 黑：5逆临（2） 红：5逆临（2）\n5单色是最具代表性的颜色差异牌，直接分出了绿蓝和白黑红两个颜色阵营，行动数量-分数比一般为5:2=2.5，由于绿蓝的单5是强化本色，因此价值略高于白黑红。这张牌很直观的比楼上53少用3个宝石，加上黄金的压力对比单6要轻不少，前期可以考虑预留。\n421： 4顺对 2顺临 1逆对（2）\n个人认为的前期最强牌，行动数量-分数比一般为4:2=2，在有不俗性价比的同时对黄金的需求很低，只需要1个甚至0个黄金就可以完成，这使得前期421开局不但不会被卡，后续也非常灵活，进可快攻抢大分，退可卡金凑贵族。因为421的需求颜色构成和三级牌不相符，所以中后期421价值反而有所下降，但仍然是一张可选牌。\n332： 3顺对 3逆临 2本色（1）\n8宝石换1分，行动数量-分数比一般为4:1=4，较低的性价和混乱颜色需求比使得大部分情况下无人问津。\n322： 绿：3顺临 2顺对 2逆对（1） 蓝：3逆对 2逆临 2本色（1） 白：3逆对 2顺临 2顺对（1） 黑：3逆临 2顺对 2逆对（1） 红：3逆临 2逆对 2本色（1）\n和332类似的地位，行动数量-分数比一般为4：1=4，优势是唯二不需要黄金就可以获得的分数牌，在某些卡金卡得丧心病狂的局里会有不错的表现。\n二级牌小结：二级牌作为既容易打出，分数性价比又高的牌，是游戏中争夺激烈的主要战场。其在游戏中需求量最大，轮换速度也最快，因此相对于另外两个等级，研究二级牌的颜色搭配是最重要也最常用的。在二级牌中的强牌里，可以明显看到绿蓝双色相对独立，而白黑红三色闭环相关联，自然而然的，绿蓝和白黑红就变成了冲分流里最常见的两组颜色搭配，它们不但互成体系，而且有更大的拿贵族机会。\n四．一级卡（40张）： # 单4： 4逆对（1）\n一级牌里唯一有分的牌，行动数量-分数比一般为：4:1=4，考虑到有资源剩余，它的性价比甚至高于二级牌的332和322。从跑分的角度看前期单4的性价比不太够看，但是潜力巨大，到中后期，它每靠牌节省1资源，它的性价比就会有巨大的提升，关键时刻补分有奇效。也可以考虑前期先做，但是如果选择前期做一定要充分发挥它卡金的优势，争取把别人卡住，否则正常发育的情况下以它的性价比来说是比较吃亏的。\n311： 绿：3顺临 1本色 1顺对 蓝：3逆临 1本色 1逆对 白：3本色 1顺临 1逆临 黑：3顺临 1本色 1顺对 红：3逆临 1本色 1逆对\n0分一级卡中最昂贵的一张牌，前期在同颜色的一级卡中一般都是最后一个考虑的。但是到后期由于311的颜色需求比较科学，符合绿蓝，白黑红两种主流的颜色搭配，在争贵族补色的时候经常会有用武之地。\n221： 2逆对 2逆临 1顺临\n同样属于昂贵的0分一级牌，颜色搭配也不尽如人意，一般前期没有更好的选择时才会选择用它补色。\n2111： 2逆对 1逆临 1顺临 1顺对\n都说卡牌游戏没有完爆，但璀璨宝石里的2111确实被1111完爆。不过对于1级牌，重点是关键时刻需要它们来补色，价格多一点少一点往往是次要的。\n22： 绿：2顺临 2逆临 蓝：2顺对 2逆临 白：2顺临 2逆临 黑：2顺对 2逆临 红：2本色 2逆对\n比较便宜的一级牌，其中红22的颜色需求比较贴白黑红流派。\n1111 1顺临 1顺对 1逆对 1逆临\n比较便宜的一级牌，补色优先级很高。\n单3： 绿：3逆临 蓝：3顺对 白：3逆临 黑：3顺对 红：3逆对\n单3虽然只需3个宝石，但是做成的难度反而比需要4个宝石的一级牌大，所以优先级比较低，其中红单3比较贴白黑红流派。\n21： 2顺对 1顺临\n最便宜的一级牌，如果能拿到自己需要的颜色就是血赚。\n一级牌小结：由于一级牌的价值主要是跟着翻出的三级牌和贵族走，因此很容易出现翻出的4张一级牌都没啥用从而卡住的局面。但是一级牌的更新速度慢也赋予了它物以稀为贵的特点，抢手颜色一级牌的价值不亚于，甚至高于一个黄金的价值。\n总结 # 从卡牌上五色需求的规律来看，绿蓝和白黑红无疑是最高效的两个组合。其中绿蓝流前中期蓝牌价值更高一点，因为便于后期做对蓝需求大的绿牌，如果有44绿蓝贵族，先做蓝再做绿是节奏最好的。白黑红的完美节奏是优先做黑，后期由黑出高分白，再用黑白补红色一二级牌，完成333白黑红贵族。\n","date":"2024-05-27","externalUrl":null,"permalink":"/funs/boardgame/splendor/","section":"Funs","summary":"","title":"璀璨宝石牌型分析","type":"funs"},{"content":" 1. Mac 键盘符号说明 # ⌘ == Command ⇧ == Shift ⇪ == Caps Lock ⌥ == Option ⌃ == Control ↩ == Return/Enter ⌫ == Delete ⌦ == 向前删除键（Fn+Delete） ↑ == 上箭头 ↓ == 下箭头 ← == 左箭头 → == 右箭头 ⇞ == Page Up（Fn+↑） ⇟ == Page Down（Fn+↓） Home == Fn + ← End == Fn + → ⇥ == 右制表符（Tab键） ⇤ == 左制表符（Shift+Tab） ⎋ == Escape (Esc) ⏏ == 电源开关键 2. 常用 # 描述 Mac 快捷键 显示命令面板 ⇧⌘P, F1 快速打开 ⌘P 新建 窗口/实例 ⌘N(之前的：⇧⌘N) 关闭 窗口/实例 ⌘W 侧边栏开关 command + B 控制台开关 command + J 合并当前行 control + J 整个项目搜索内容 command + shift + F 创建分屏快捷键 command + \\ 批量替换当前文件中所有匹配的文本 command + F2 复制光标向上或向下批量添加内容 option + command + 上下箭头 切换tab显示 option + command + 左右箭头 3. 基本编辑 # Mac 快捷键 介绍 ⌘X 剪切 ⌘C 复制 ⌥↓ / ⌥↑ 移动当前行向 下/上 ⇧⌥↓ / ⇧⌥↑ 复制当前行向 下/上 ⇧⌘K 删除当前行 ⌘Enter / ⇧⌘Enter 在下/上 插入一行 ⇧⌘\\ 跳转到匹配的括号 ⌘] / ⌘[ 向左/向右 缩进当前行 Home / End 跳到当前行的头部，尾部 ⌘↑ / ⌘↓ 跳到当前行的开始，结束 ⌃PgUp 滚动到 ⌃PgDown 滚动到行头/行尾 ⌘PgUp /⌘PgDown 滚动到页头/页尾 ⇧⌘[ / ⇧⌘] 折叠/展开区域 ⌘K ⌘[ / ⌘K ⌘] 折叠/展开所有子区域 ⌘K ⌘0 / ⌘K ⌘J 折叠/展开所有区域 ⌘K ⌘C 添加行注释 ⌘K ⌘U 删除行注释 ⌘/ 切换行注释 ⇧⌥A 切换块注释 ⌥Z 切换文字换行 4. 多光标和选择 # Mac 快捷键 介绍 Alt+Click 插入光标 ⌥⌘↑ 在上面插入光标 ⌥⌘↓ 在下面插入光标 ⌘U 撤消上一个光标操作 ⇧⌥I 在所选每行的末尾插入光标 ⌘I 选择当前行 ⇧⌘L 选择当前选择的所有事件 ⌘F2 选择当前单词的所有出现 ⌃⇧⌘→ 展开选择 ⌃⇧⌘← 收缩选择 Shift+Alt + drag mouse（拖动鼠标） 列（框）选择 ⇧⌥⌘↑ 向上列（框）选择 ⇧⌥⌘↓ 向下列（框）选择 ⇧⌥⌘← 向左列（框）选择 ⇧⌥⌘→ 向右列（框）选择 ⇧⌥⌘PgUp 列（框）选择 向上一页 ⇧⌥⌘PgDown 列（框）选择 向下一页 5. 搜索和替换 # Mac 快捷键 介绍 ⌘F 查找 ⌥⌘F 替换 ⌘G / ⇧⌘G 查找下一个/上一个 ⌥Enter 选择查找匹配的所有匹配项 ⌘D 将选择添加到下一个查找匹配 ⌘K ⌘D 将最后一个选择移至下一个查找匹配项 6. 丰富的语言编辑 # Mac 快捷键 介绍 ⌃Space 触发建议 ⇧⌘Space 触发参数提示 Tab Emmet扩展缩写 ⇧⌥F 格式化文档 ⌘K ⌘F 格式选择 F12 转到定义 ⌥F12 Peek定义 ⌘K F12 打开定义到一边 ⌘. 快速修复 ⇧F12 显示引用 F2 重命名符号 ⇧⌘. / ⇧⌘, 替换为下一个/上一个值 ⌘K ⌘X 修剪尾随空格 ⌘K M 更改文件语言 7. 导航 # Mac 快捷键 介绍 ⌘T 显示所有符号 ⌃G 转到行… ⌘P 转到文件… ⇧⌘O 转到符号… ⇧⌘M 显示问题“面板” F8 / ⇧F8 转到下一个/上一个错误或警告 ⌃⇧Tab 浏览编辑器组历史记录 ⌃- / ⌃⇧- 后退/前进 ⌃⇧M 切换选项卡移动焦点 8. 编辑器管理 # Mac 快捷键 介绍 ⌘W 关闭编辑窗口 ⌘K F 关闭文件 ⌘\\ 拆分编辑窗口 ⌘1 / ⌘2 / ⌘3 聚焦到第1，第2，第3编辑器组中 ⌘K ⌘← / ⌘K ⌘→ 聚焦到上一个/下一个编辑器组 ⌘K ⇧⌘← / ⌘K ⇧⌘→ 向左/向右移动编辑器 ⌘K ← / ⌘K → 移动活动编辑器组 9. 文件管理 # Mac 快捷键 介绍 ⌘N 新建文件 ⌘O 打开文件 ⌘S 保存 ⇧⌘S 保存为… ⌥⌘S 保存所有 ⌘W 关闭 ⌘K ⌘W 关闭所有 ⇧⌘T 重新打开已关闭的编辑器 ⌘K 输入保持打开 ⌃Tab / ⌃⇧ 选项卡打开下一个/上一个 ⌘K P 复制活动文件的路径 ⌘K R 在资源管理器中显示活动文件 ⌘K O 在新窗口/实例中显示活动文件 10. 显示 # Mac 快捷键 介绍 ⌃⌘F 切换全屏 ⌥⌘1 切换编辑器布局 ⌘= / ⇧⌘- 放大/缩小 ⌘B 切换侧栏可见性 ⇧⌘E 显示资源管理器/切换焦点 ⇧⌘F 显示搜索 ⌃⇧G 显示Git ⇧⌘D 显示Debug ⇧⌘X 显示扩展名 ⇧⌘H 在文件中替换 ⇧⌘J 切换搜索详细信息 ⇧⌘C 打开新命令提示符/终端 ⇧⌘U 显示输出面板 ⇧⌘V 切换Markdown预览 ⌘K V 打开Markdown预览到一边 11. 调试 # Mac 快捷键 介绍 F9 切换断点 F5 开始/继续 F11 / ⇧F11 跳进/出 F10 跳过 ⇧F5 暂停 ⌘K ⌘I 显示悬停 12. 集成终端 # Mac 快捷键 介绍 ⌃` 显示集成终端 ⌃⇧` 创建新终端 unassigned（末分配） 复制选择 unassigned（末分配） 粘贴到活动终端 ⌘↑ 向上滑动 ⌘↓ 下身滑动 PgUp 向上滚动页面 PgDown 向下滚动页面 ⌘Home 滚动到顶部 ⌘End 滚动到尾部 参考资料 # VScode官网 快捷键 Mac 版\nVisual Studio Code 快捷键 Mac 版 CSDN\nhttps://code.visualstudio.com/docs/getstarted/keybindings\n","date":"2024-05-07","externalUrl":null,"permalink":"/posts/vscode_tutorial/","section":"文章","summary":"","title":"Mac版Vscode快捷键速查","type":"posts"},{"content":"","date":"2024-05-07","externalUrl":null,"permalink":"/tags/%E6%9F%A5%E8%AF%A2/","section":"Tags","summary":"","title":"查询","type":"tags"},{"content":" 1. 光标控制 # 快捷键 描述 ⌃ + a 到行首 ⌃ + e 行末 ⌃ + f/b 前进后退，相当于左右方向键 ⌃ + p 上一条命令，相当于方向键上 ⌃ + r 搜索命令历史 ⌃ + d 删除当前字符 ⌃ + h 删除之前的字符 ⌃ + w 删除光标前的单词 ⌃ + k 删除到文本末尾 ⌃ + t 交换光标处文本 ⌘ + —/+/0 调整字体大小 ⌘ + r 清屏 ⌃ + l 清屏（滚动到新的一屏） 2. 终端操作快捷键 # 2.1 窗口面板管理：一个窗口分割 # 快捷键 描述 垂直分割 ⌘ + D 水平分割 ⇧ + ⌘ + D 前一个面板 ⌘ + [ 或 ⌥ + ⌘ + 左右方向键 后一个面板 ⌘ + ] 切换到上/下/左/右面板 ⌥ + ⌘ + 上下左右方向键 关闭panel ⌘ + w 最大化Tab中的pane，隐藏本Tab中的其他pane ⌘+ ⇧ +enter 2.2 新建Tab标签页 # 快捷键 描述 新建标签页 ⌘ + T 关闭标签页 ⌘ + W 前一个标签页 ⌘ + 左方向键，⇧ + ⌘ + [ 后一个标签页 ⌘ + 右方向键，⇧ + ⌘ + ] 进入标签页 ⌘ + 标签页编号 Expose 标签页 ⌥ + ⌘ + E 快速定位光标位置 ⌘ + / 2.3 多个窗口操作 # 快捷键 描述 新建窗口 ⌘ + N 关闭窗口 ⌘ + w 前一个窗口 ⌘ + ` 后一个窗口 ⇧ + ⌘ + ` 进入窗口 ⌥ + ⌘ + 编号 2.4 其他功能 # 支持自定义全局快捷键用于显示和隐藏iTerm2 Preference -\u0026gt; Keys －\u0026gt; Show/hide iTerm2 with a system-wide hotkey 打上勾之后 快捷键 描述 进入和退出全屏 ⌘ + Enter 查看光标位置 ⌘ + / 命令自动补全 ⌘ + ;（较少使用，Zsh补全更佳） 开启/关闭背景半透明 ⌘ + u 清屏 ⌘ + r 2.4.1 粘贴历史 # 使用⌘ + ⇧ + h 可以呼出粘贴历史，支持模糊检索。还可以设置将粘贴历史保存在磁盘上（Preferences -\u0026gt; General）\n2.4.2 即时回放 # 使用⌘ + Opt + b 打开即时回放，按Esc退出。即时回放可以记录终端输出的状态，让你“穿越时间”查看终端内容。默认每个会话最多储存4MB的内容，可以在设置中更改（Preferences -\u0026gt; Genernal -\u0026gt; Instant Replay）。\n2.5 自定义快捷键设置 # 2.5.1设置光标按照单词快速移动 # iTerm2之后，发现⌥+←和⌥+→这两组快捷键并不能实现光标按照单词快速移动，\n在Mac自带的终端中是可以使用这两个快捷键的，经过查找和测试发现，需要重新配置相应的映射。iTerm2中将这两组快捷键用作了其他的功能。\n打开iTerm2的Preferences设置 选择相应的Profile（默认为Default），选择“Keys”选项卡，然后可以在Key Mappings看到⌥+←和⌥+→这两组快捷键用作了其他功能，这里我们只需要重新绑定新的映射即可 找到⌥+← ， 双击就会弹出一个编辑框，选择Action为“Send Escape Sequence”, 然后在 Esc+选项中输入b 找到⌥+→， 双击就会弹出一个编辑框，选择Action为“Send Escape Sequence”, 然后在 Esc+选项中输入f 修改映射之后，再重新启动iTerm2就可以使用⌥+←和⌥+→来实现光标按单词快速移动了，非常方便。如果不想使用⌥+←和⌥+→这两个组合键的话，也可以自行添加新的Shortcut即可。\n3. 个性化的设置 # 3.1 设置无分栏边框 # preference-\u0026gt;appearance：\n取消：Show per-pane title bar with split panes\n勾选：Hide scrollbars\n3.2 终端显示边框 # preference-\u0026gt;appearance：\n勾选：Show border around window\n3.2 显示、隐藏终端快捷键 # Preferences -\u0026gt; Keys -\u0026gt; Hotkey:\n勾选： Show/hide iTerm2 with a system-wide hotkey\n然后在下面的Hotkey里面填上F12，\n这个F12可能被系统占用了，这修改系统的快捷键，或更换别的快捷键。\n3.3 鼠标移动切换窗口 # 当一个终端打开了多个窗口，可以设置鼠标移动窗口时获取焦点\nPreferences -\u0026gt; Pointer:\n勾选：Focus follows mouse\n3.4 设置光标形状 # Preferences -\u0026gt; Profiles -\u0026gt; Profile Name -\u0026gt; Text -\u0026gt; Cursor\n选择一个自己喜欢的样式\n3.5 新窗口打开的路径跟当前终端的路径一直 # Preferences -\u0026gt; Profiles -\u0026gt; General -\u0026gt; Working Directory -\u0026gt; reuse previous session\u0026rsquo;s directory\n3.6 新窗口在电脑获取焦点的窗口生成 # Preferences -\u0026gt; Profiles -\u0026gt; General -\u0026gt; Window -\u0026gt; Settings for New Windows -\u0026gt; Screen\n选择：No Preference\n或者选择：Screen with Cursor（在鼠标的窗口）\n3.7 设置开机启动不显示界面 # 1、打开系统设置(System Perferences) -\u0026gt; 用户与群组(User \u0026amp; groups) -\u0026gt; 登陆项(Login Items)， 点击加号，然后去应用程序里面找到Iterm2添加到启动项里面。 2、启动iterm2程序，打开一个窗口，然后手动点击关闭按钮，确保电脑右上角苹果图标右边是iTerm2,然后 按【⌘】+【⇧】+【S】，保存名为No Window 3、打开一个iterm2终端界面，然后按cmd + ,打开iterm的设置界面，选择Arrangements，点击刚才保存的No Window， 然后点击Set Default。 4、在iterm的设置界面选择General, 在Startup中选择Open Default Window Arrangement。\n参考资料 # iterm2使用快捷键\n关于iTerm2 你不知道的一些事\nMac下iTerm2光标按照单词快速移动设置\n打造有情怀的 iTerm2 终端\n","date":"2024-05-06","externalUrl":null,"permalink":"/posts/iterm2_tutorial/","section":"文章","summary":"","title":"Iterm2快捷键速查","type":"posts"},{"content":"","date":"2024 April 11","externalUrl":null,"permalink":"/en/tags/latex/","section":"Tags","summary":"","title":"Latex","type":"tags"},{"content":"In the process of writing papers, creating presentations in PowerPoint, and editing documents in Word, Markdown, and Latex, we often encounter issues with remembering how to edit certain symbols. Here, I\u0026rsquo;m reposting some content from the Latex documentation for easy reference.\nPart 1：Greek/Hebrew characters, mathematical construction symbols, separators, variable length symbols in formulas, standard functions # Part 2：Binary operators and relational symbols # Part 3：Arrows, calculus sets, musical notes, mathematical mode accents # Part 4：Array environment, other mathematical styles, font sizes, text accent symbols # ","date":"2024 April 11","externalUrl":null,"permalink":"/en/posts/latex_symbols/","section":"Posts","summary":"In the process of writing papers, creating presentations in PowerPoint, and editing documents in Word, Markdown, and Latex, we often encounter issues with remembering how to edit certain symbols.","title":"Latex Symbol Quick Reference Guide","type":"posts"},{"content":"","date":"2024 April 11","externalUrl":null,"permalink":"/en/tags/markdown/","section":"Tags","summary":"","title":"Markdown","type":"tags"},{"content":"","date":"2024 April 11","externalUrl":null,"permalink":"/en/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2024 April 11","externalUrl":null,"permalink":"/en/tags/query/","section":"Tags","summary":"","title":"Query","type":"tags"},{"content":"","date":"2024 April 11","externalUrl":null,"permalink":"/en/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2024 April 11","externalUrl":null,"permalink":"/en/","section":"Witchcraft's space","summary":"","title":"Witchcraft's space","type":"page"},{"content":" 图网络 # 背景 # ​常见的神经网络，如BP神经网络可以用来处理表格型的数据，卷积神经网络可以用来处理图片数据，循环神经网络则可以用来处理序列数据，这些数据都是结构化的数据，当我们需要处理的数据为图这种非结构化的数据，例如：城市交通的每个路口上的传感器所记录的数据；化学分子结构；人际关系网；推荐系统中每个人构成的图。并不是说以上的神经网络处理不了图这种类型的数据，只是在处理图这种数据上存在欠缺，图数据有一个很明显的特征，相邻或相近的节点存在一定的空间依赖关系，这种关系传统神经网络很难捕获。为了获取表示这种特征关系，图网络就此诞生。\n内容 # ​图网络的核心思想就是依据图结构的空间依赖关系来表征现实世界中真实的特征之间的相互作用关系，通过对节点特征进行聚合生成新的节点特征表示用于后续工作。\n​下图为一张交通系统的图结构，在6个位置上分别有一个传感器记录了一段时间的交通流量数据，现在的目标是要预测接下来每个位置上未来一段时间的流量。如果从传统的时间序列模型来思考，未来的数据一定是与过去的数据相关，因此我们可以对6个位置的时间序列单独进行预测生成6个位置未来的预测值，但是这样就没有考虑到节点之间的空间依赖关系。既然已经用图结构表示出了这种空间关系，那么我们怎么去应用它？这就是图网络所要解决的问题。\nGCN(Graph Convolutional Network) # 论文：https://arxiv.org/pdf/1609.02907.pdf\n​GCN（图卷积神经网络），实际上跟CNN（卷积神经网络）的作用一样，就是一个特征提取器，只不过它的对象是图数据。GCN精妙地设计了一种从图数据中提取特征的方法，从而让我们可以使用这些特征去对图数据进行节点分类（node classification）、图分类（graph classification）、边预测（link prediction），还可以顺便得到图的嵌入表示（graph embedding）。下图为GCN和输入图像数据的CNN间的对比。\n常规邻接矩阵 # 假设有一批图数据，其中有N个节点（node），每个节点都有自己的特征，假设特征一共有D个，我们设这些节点的特征组成一个N×D维的矩阵X，然后各个节点之间的关系也会形成一个N×N维的矩阵A，也称为邻接矩阵（adjacency matrix）。X和A便是我们模型的输入。\n假设现在有这样一个图结构，有ABCDE五个节点，每个节点之间的相互关系以及每个节点的特征如下图。\n现在我要重新计算E的特征，根据GCN的基本思想，就是要聚合其邻居节点的信息，也就是ABCD的特征以一定方式进行聚合（平均、求和、拼接等），以求和为例：\n因为E和ABCD四个节点都相连，因此其聚类后的新特征为ABCD四点对应特征之和。而如果将其放在矩阵乘法运算中则为邻接矩阵和特征矩阵的乘积：\n设n为节点数，f为每个节点的特征维度，则邻接矩阵A的形状为 (n,n) ,特征矩阵的形状为 (n,f) ，AX相乘后表示考虑到邻居节点信息的新的特征矩阵，形状为 (n,f) ，每一行表示一个节点的特征，可以看出新的E节点，我们能一次性将所有的节点特征表示出来。\n考虑自身信息的邻接矩阵 # 刚刚提到的常规的邻接矩阵的中，两个不同的节点B和C在经过邻接矩阵的运算后，新的特征向量完全一致，然而这是两个具有不同位置信息、不同特征的不同节点，得出来一样的结果明显是不合理的。因此为了防止这种情况，在计算新的节点特征时，不仅要考虑邻居节点的信息，也可以将自身节点的信息考虑进去。在邻接矩阵上面的表现就是加上了一个单位阵： $$ \\tilde A = A + I $$ 接着将得到的新邻接矩阵与特征矩阵相乘的到新的特征矩阵\n可以看出，加入单位矩阵之后，B和C虽然具有相同的邻居，但是由于自身的特征不一样，所以空间变换后的特征也不一样。单位矩阵的加入，使得矩阵相乘时，考虑到了自身节点的信息的因素。\n求平均/归一化 # 采用之前的方式，相当于我们对所有节点的邻居及自身进行了求和，但是这种聚合方式是有问题的，相当于我们变相的改变了特征的量级。我们每进行一次聚合，就加大了一次量级。随着迭代的增加，量级会越来越大，假设现在我要求小明的收入，那么采用求和的方式就会将小明的邻居朋友们及自己的收入加起来，这显然是错误的。因此更好地方式是求平均，类比到图结构中就是左乘我们的度矩阵。\n其中度矩阵就是与该节点相邻节点的数据，因此就是邻接矩阵A每一行的求和组成的对角阵 $$ D=\\Sigma_jA_{ij} $$\n同样的这种方式也只考虑到了邻居节点的个数而没有考虑到自身的信息，因此在度矩阵D上在加上单位阵 I ，也即$\\tilde A$的每一行的求和，即： $$ \\tilde D=D+I=\\Sigma_j\\tilde A_{ij} $$ 所以最终的求平均的操作就为 $ \\tilde D^{-1}\\tilde AX$，由于矩阵乘法满足结合律，所以 $ \\tilde D^{-1}\\tilde AX = \\tilde D^{-1}(\\tilde AX)$，又由于 $ \\tilde D^{-1}$ 为初等矩阵，左乘初等矩阵相当于行变换，所以相当于对$ \\tilde AX $的每一行除以度，相当于对每一个节点求和后的特征做平均。\n这就是邻接矩阵的归一化。\n","date":"2024-04-07","externalUrl":null,"permalink":"/posts/gnn_pt1/","section":"文章","summary":"","title":"图神经网络学习笔记（1）","type":"posts"},{"content":" This page is translated by GPT-4\nThis article is a reprint of a setup guide I wrote during my internship, and the content has been anonymized.\nWhy this？ # Jupyter Lab is a web-based interactive development environment that allows users to edit, run, and share code visually. Users can execute code step by step, which is suitable for tasks such as data analysis, scientific computing, machine learning, etc. Especially for data processing tasks like PySpark, using Jupyter displays the results of each process, facilitating a deeper understanding of data processing and code learning.\nzsh is an alternative to bash, offering almost the same functionality. However, with a configuration management tool like oh-my-zsh, zsh can install various plugins and themes, allowing users to customize it according to their needs and preferences, thereby enhancing development efficiency.\nConfiguring Jupyter # First, enter your own environment on the server\nssh your_server_address Installing Anaconda # Download the installation script from Tsinghua mirror source https://repo.anaconda.com/archive/. Please choose the version corresponding to the server architecture.\nExecute the installation script in your own environment on the server. After proceeding with yes, it will by default install in the path ~/anaconda3. Try running conda \u0026ndash;version to check if it\u0026rsquo;s successfully installed. If the command is not found, try re-entering or source ~/.bashrc.\nInstalling Jupyter # Create a sub-environment to install common Jupyter packages. Change the name after -n to your own environment name.\nconda create -n py3.7_env python=3.7 jupyterlab numpy pandas scipy Add the following content at the end of ~/.bashrc, which sets the environment with Jupyter installed as the default start-up and configures common hdfs commands. Change the first line\u0026rsquo;s environment name to the one you previously created, and change HHOME and sp to your name.\nconda activate py3.7_env export HADOOP_USER_NAME=xxx export HADOOP_USER_PASSWORD=xxx export HHOME=\u0026#39;/user/bigdata-dp/your_name\u0026#39; export LD_LIBRARY_PATH=/lib:/usr/lib:/usr/local/lib alias hls=\u0026#34;hadoop fs -ls\u0026#34; alias hget=\u0026#34;hadoop fs -get\u0026#34; alias hput=\u0026#34;hadoop fs -put\u0026#34; alias hcat=\u0026#34;hadoop fs -cat\u0026#34; alias http=\u0026#34;python -m http.server\u0026#34; alias hdu=\u0026#34;hadoop fs -du -h\u0026#34; Setting Up Startup Script # Navigate to the path /home/odin/your_name/anaconda3/envs. Please replace the name with your own.\nExecute tar -czvf my_py37.tar ./py3.7_env to package the conda environment. Please replace the environment name and tar package name with your own.\nUpload the created tar package to the designated directory in hdfs.\nEdit start_jupyter.sh and add the following content, noting that you need to replace the following:\nIn PYSPARK_DRIVER_PYTHON_OPTS, the IP is the server IP, and you can choose any port that is not occupied. Change pyspark \u0026ndash;name to the name you have chosen. Change the path under \u0026ndash;archives to the path of the tar package previously uploaded to hdfs. Change spark.yarn.appMasterEnv.PYSPARK_PYTHON to your name\u0026rsquo;s path. export HADOOP_USER_NAME=xxx export HADOOP_USER_PASSWORD=xxx export PYSPARK_DRIVER_PYTHON=jupyter export PYSPARK_DRIVER_PYTHON_OPTS=\u0026#39;lab --port=8066 --ip=your_ip_address\u0026#39; export SPARK_HOME=/usr/local/spark-current pyspark --name your_name_data_process \\ --queue root.your_queue_name \\ --driver-memory 8g --executor-memory 13g \\ --executor-cores 3 --num-executors 100 \\ --conf spark.task.cpus=3 \\ --conf \u0026#34;spark.driver.extraJavaOptions=-Dcom.github.fommil.netlib.BLAS=com.github.fommil.netlib.F2jBLAS\u0026#34; \\ --conf \u0026#34;spark.executor.extraJavaOptions=-Dcom.github.fommil.netlib.BLAS=com.github.fommil.netlib.F2jBLAS\u0026#34;\\ --conf spark.default.parallelism=1300 \\ --conf spark.sql.shuffle.partitions=1300 \\ --conf spark.sql.broadcastTimeout=3600 \\ --conf spark.shuffle.memoryFraction=0.6 \\ --conf spark.yarn.executor.memoryoverhead=13000M \\ --conf spark.yarn.appMasterEnv.PYSPARK_PYTHON=./mypython/py3.7_env/bin/python \\ --conf spark.port.maxRetries=300 \\ --conf spark.yarn.priority=100 \\ --archives hdfs://DClusterNmg3:8020/user/your_path/your_name/my_py37.tar#mypython \\ Execute nohup sh start_jupyter.sh \u0026gt;jupyter.log\u0026amp; to start the jupyter service. You can find the access link in jupyter.log, copy it to the browser to use.\n(Optional) Install the dark mode interface for jupyter lab, install it according to your needs, and you can switch in settings-\u0026gt;theme after installation.\npip install jupyterlab_darkside_ui -i https://pypi.tuna.tsinghua.edu.cn/simple Configuring zsh # Considering accessing the github link to install oh-my-zsh is often slow on servers, it is recommended to first install it locally and then copy it to the server, saving time on reinstalling plugins.\nLocal Installation of oh-my-zsh (MacOS) # Mac comes with zsh installed by default, so you only need to install oh-my-zsh. Execute\nsh -c \u0026#34;$(curl -fsSL https://install.ohmyz.sh/)\u0026#34; or\nsh -c \u0026#34;$(wget -O- https://install.ohmyz.sh/)\u0026#34; After installation, the shell will automatically switch from bash to zsh.\nInstall the following two plugins as needed:\nzsh-autosuggestions: records commands entered in the past and automatically predicts suggestions when entering commands again. git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions zsh-syntax-highlighting: displays different colors based on whether the shell command can be executed. git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting After installing the above two plugins, edit ~/.zshrc and add the names of the plugins you have installed to the plugins section.\nplugins=( # other plugins... zsh-autosuggestions zsh-syntax-highlighting ) Then execute source ~/.zshrc.\nServer Installation of zsh (Linux) # Unlike MacOS, Linux terminals do not come with zsh, so you need to install zsh first before configuring oh-my-zsh.\nConsidering Linux often serves as a remote server with potentially slow internet, here we choose to use the sftp command to directly copy the locally installed zsh to the server.\nput -r ~/.oh-my-zsh put ~/.zshrc On your server environment, execute the following command to download the zsh installation package.\nwget -O zsh.tar.xz https://sourceforge.net/projects/zsh/files/latest/download --no-check-certificate If downloading is not possible due to network issues, execute the command locally and use sftp to transfer it to the server.\nExecute tar -xvf zsh.tar.xz to extract the installation package, which will create a directory named zsh-5.9.\nEnter the zsh-5.9 directory, and execute the following commands in sequence to compile and install zsh. The prefix specifies the installation directory, you can create a folder for it\ncd zsh-5.9 ./configure -prefix=xxx make -j all make install After installation, add the following content to ~/.bashrc before conda activate. Change PATH to the bin directory under the installation path of zsh from the previous step, save, and exit, but do not source yet.\nexport PATH=$PATH:/home/odin/your_name/my_zsh/bin exec zsh Server Installation of oh-my-zsh (Linux) # After navigating to the home directory, use sftp get to retrieve the previously uploaded .oh-my-zsh folder and .zshrc.\nEdit ~/.zshrc and add the following sections at the end. The content below is just an example, please copy the corresponding content from your own .bashrc.\n# \u0026gt;\u0026gt;\u0026gt; conda initialize \u0026gt;\u0026gt;\u0026gt; # !! Contents within this block are managed by \u0026#39;conda init\u0026#39; !! __conda_setup=\u0026#34;$(\u0026#39;/home/odin/your_name/anaconda3/bin/conda\u0026#39; \u0026#39;shell.bash\u0026#39; \u0026#39;hook\u0026#39; 2\u0026gt; /dev/null)\u0026#34; if [ $? -eq 0 ]; then eval \u0026#34;$__conda_setup\u0026#34; else if [ -f \u0026#34;/home/odin/your_name_i/anaconda3/etc/profile.d/conda.sh\u0026#34; ]; then . \u0026#34;/home/odin/your_name_i/anaconda3/etc/profile.d/conda.sh\u0026#34; else export PATH=\u0026#34;/home/odin/your_name/anaconda3/bin:$PATH\u0026#34; fi fi unset __conda_setup # \u0026lt;\u0026lt;\u0026lt; conda initialize \u0026lt;\u0026lt;\u0026lt; conda activate py3.7_env export HADOOP_USER_NAME=xxx export HADOOP_USER_PASSWORD=xxxxx export HHOME=\u0026#39;/user/bigdata-dp/your_name\u0026#39; export LD_LIBRARY_PATH=/lib:/usr/lib:/usr/local/lib alias hls=\u0026#34;hadoop fs -ls\u0026#34; alias hget=\u0026#34;hadoop fs -get\u0026#34; alias hput=\u0026#34;hadoop fs -put\u0026#34; alias hcat=\u0026#34;hadoop fs -cat\u0026#34; alias http=\u0026#34;python -m http.server\u0026#34; alias hdu=\u0026#34;hadoop fs -du -h\u0026#34; Add the following to ~/.zshrc to prevent color display issues in zsh.\nexport TERM=xterm-256color Save and exit .zshrc, then execute source ~/.bashrc to complete the installation.\n(Optional) Change the theme: You can replace different themes by modifying ZSH_THEME=\u0026ldquo;robbyrussell\u0026rdquo; in ~/.zshrc. Refer to the content on the following webpage for replacement: https://github.com/ohmyzsh/ohmyzsh/wiki/Themes\n(Optional) Change fonts, customize zsh theme: https://juejin.cn/post/6844904178075058189#heading-32\n","date":"2024 April 3","externalUrl":null,"permalink":"/en/posts/build_jupyter_zsh/","section":"Posts","summary":"This page is translated by GPT-4","title":"Configuring Jupyter and zsh for Local and Server Environments on MacOS","type":"posts"},{"content":"","date":"2024 April 3","externalUrl":null,"permalink":"/en/tags/env-config/","section":"Tags","summary":"","title":"Env Config","type":"tags"},{"content":"","date":"2024 April 3","externalUrl":null,"permalink":"/en/tags/jupyter/","section":"Tags","summary":"","title":"Jupyter","type":"tags"},{"content":"","date":"2024 April 3","externalUrl":null,"permalink":"/en/tags/linux/","section":"Tags","summary":"","title":"Linux","type":"tags"},{"content":"","date":"2024 April 3","externalUrl":null,"permalink":"/en/tags/mac/","section":"Tags","summary":"","title":"Mac","type":"tags"},{"content":"","date":"2024-04-03","externalUrl":null,"permalink":"/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","section":"Tags","summary":"","title":"环境配置","type":"tags"},{"content":"不同Hugo主题对Markdown语法的支持程度不同，因此本页面用于检测不同Markdown语法在本主题中的兼容情况\n语言分块 # All I can think about is you!\nWell down! It\u0026rsquo;s good!\nNext paragraph!\n斜体 # well down\n分割线 # 粗体 # good\n粗斜体 # well\n横线 # well\n下划线 # underline\n脚注 # 要介绍的是1\n列表 # 第一点 第二点 第二第一 211 wo wowo wo 牛啊 good 212 第二第二 ho ho again 第三点 第四点 区块引用 # 区块引用\n这真是太棒了\n内部嵌套\n哇哦\n函数块 # printf()是一个C语言函数\n代码块 # int a = 0; void printALL{ for(int i = 0 ;i \u0026lt; a;i++){ cout \u0026lt;\u0026lt; \u0026#34;Ho\u0026#34;; } } 链接 # 百度官方网站百度\nhttps://www.baidu.com\n这个链接good\n图片 # 表格 # title1 title2 title3 one things two things three things first second third 键盘块 # shift and del = S Latex # $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n$$ f(a,b,c) = (a^2+b^2+c^2)^3 $$\nMermaid # 横向流程图 # graph LR A[方形] --\u003eB(圆角) B --\u003e C{条件a} C --\u003e|a=1| D[结果1] C --\u003e|a=2| E[结果2] F[横向流程图] 纵向流程图 # graph TD A[方形] --\u003e B(圆角) B --\u003e C{条件a} C --\u003e |a=1| D[结果1] C --\u003e |a=2| E[结果2] F[竖向流程图] 标准纵向流程图 # st=\u003estart: 开始框 op=\u003eoperation: 处理框 cond=\u003econdition: 判断框(是或否?) sub1=\u003esubroutine: 子流程 io=\u003einputoutput: 输入输出框 e=\u003eend: 结束框 st-\u003eop-\u003econd cond(yes)-\u003eio-\u003ee cond(no)-\u003esub1(right)-\u003eop UML时序图 # sequenceDiagram participant 张三 participant 李四 张三-\u003e王五: 王五你好吗？ loop 健康检查 王五-\u003e王五: 与疾病战斗 end Note right of 王五: 合理 食物 看医生... 李四--\u003e\u003e张三: 很好! 王五-\u003e李四: 你怎么样? 李四--\u003e王五: 很好! 标准UML时序图 # 对象A-\u003e对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B--\u003e对象A: 我很好(响应) 对象A-\u003e对象B: 你真的好吗？ 脚注尾部 # A game company\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-04-03","externalUrl":null,"permalink":"/posts/markdown_test/","section":"文章","summary":"","title":"Markdown语法兼容性测试","type":"posts"},{"content":"","date":"2024-04-03","externalUrl":null,"permalink":"/tags/%E6%B5%8B%E8%AF%95/","section":"Tags","summary":"","title":"测试","type":"tags"},{"content":"","date":"2024-04-03","externalUrl":null,"permalink":"/series/%E6%B5%8B%E8%AF%95%E7%94%A8%E5%86%85%E5%AE%B9/","section":"Series","summary":"","title":"测试用内容","type":"series"},{"content":" 你好，世界！ # 这是本站的第一篇推文\n本站使用基于Go的Hugo引擎构建于Github Pages\n本文的剩余部分用于测试 本主题(Blowfish) 独有的各种语法功能\n测试警告语句 测试Timeline语句\nheader Repository Github建立仓库 2024.04.02 于Github建立网站代码仓库 Another Awesome Header code 代码编写 2024.04.03选取构建代码引擎 Jekyll-Hydejeck Hugo-Blowfish Shortcodes AWESOME 2024.04.03上传第一篇推文 测试嵌入Youtube视频\n","date":"2024-04-03","externalUrl":null,"permalink":"/posts/first_page/","section":"文章","summary":"","title":"Hello World","type":"posts"},{"content":"","externalUrl":null,"permalink":"/en/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/en/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/en/series/","section":"Series","summary":"","title":"Series","type":"series"}]